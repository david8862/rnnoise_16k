// -----------------------------------------------------------------------------
// Tool to dump RNNoise/RNNVad model weights from librnnvad.a to c code file, e.g. rnn_data.c
//
// Reference:
// https://blog.csdn.net/lftxd1/article/details/123927528
//
// Step for dump:
// $ ar x speechengine/third_party/x86_64/rr_vad/rnnvad/librnnvad.a rnn_data.o
// $ objdump -t rnn_data.o
// $ gcc rnnoise_weight_dump.c rnn_data.o -o rnnoise_weight_dump
// $ ./rnnoise_weight_dump -h
// Usage: rnnoise_weight_dump
// --output_file, -o: output c code file for rnnoise model weights. default: rnn_data.c
//
// $ ./rnnoise_weight_dump -o rnn_data.c
//
// Replace "src/rnn_data.c" with the generated "rnn_data.c", and rebuild the
// RNNoise lib & samples, then you can use the dumped model weights to inference
// -----------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <math.h>

#include "../src/rnn.h"
#include "../src/rnn_data.h"


int dump_array(const char* name, const rnn_weight *data, int size, FILE* fp) {
    fprintf(fp, "static const rnn_weight %s[%d] = {\n", name, size);
    int i = 0;

    for(;i < size; ++i) {
        fprintf(fp, " %d,", (int)(data[i]));
        if(i > 0 && i % 8 == 0)
            fprintf(fp, "\n");
    }

    fprintf(fp, "\n};\n");
    return 0;
}


int rnnoise_weight_dump(char* output_file)
{
    FILE* fp = fopen(output_file, "w+");

    // dump header of rnn_data.c
    fprintf(fp, "/*This file is automatically generated from a Keras model*/\n" \
           "\n" \
           "#ifdef HAVE_CONFIG_H\n" \
           "#include \"config.h\"\n" \
           "#endif\n" \
           "\n" \
           "#include \"rnn.h\"\n" \
           "\n");

    // dump weights of input_dense
    dump_array("input_dense_weights", input_dense.input_weights, input_dense.nb_inputs * input_dense.nb_neurons, fp);
    fprintf(fp, "\n");
    dump_array("input_dense_bias", input_dense.bias, input_dense.nb_neurons, fp);
    fprintf(fp, "\n");

    //printf("input_dense.nb_inputs = %d\n", input_dense.nb_inputs);
    //printf("input_dense.nb_neurons = %d\n", input_dense.nb_neurons);
    //printf("input_dense.activataon = %d\n", input_dense.activation);

    // dump definition of input_dense
    fprintf(fp, "const DenseLayer input_dense = {\n" \
           "   input_dense_bias,\n" \
           "   input_dense_weights,\n" \
           "   %d, %d, ACTIVATION_TANH\n" \
           "};\n", \
           input_dense.nb_inputs, \
           input_dense.nb_neurons
           );
    fprintf(fp, "\n");


    // dump weights of vad_gru, each GRU unit has 3 weight params
    dump_array("vad_gru_weights", vad_gru.input_weights, vad_gru.nb_inputs * vad_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");
    dump_array("vad_gru_recurrent_weights", vad_gru.recurrent_weights, vad_gru.nb_neurons * vad_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");
    dump_array("vad_gru_bias", vad_gru.bias, vad_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");

    // dump definition of vad_gru
    fprintf(fp, "const GRULayer vad_gru = {\n" \
           "   vad_gru_bias,\n" \
           "   vad_gru_weights,\n" \
           "   vad_gru_recurrent_weights,\n" \
           "   %d, %.1f, ACTIVATION_TANH\n" \
           "};\n", \
           vad_gru.nb_inputs, \
           (float)(vad_gru.nb_neurons)
           );
    fprintf(fp, "\n");


    // dump weights of noise_gru
    dump_array("noise_gru_weights", noise_gru.input_weights, noise_gru.nb_inputs * noise_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");
    dump_array("noise_gru_recurrent_weights", noise_gru.recurrent_weights, noise_gru.nb_neurons * noise_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");
    dump_array("noise_gru_bias", noise_gru.bias, noise_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");

    // dump definition of noise_gru
    fprintf(fp, "const GRULayer noise_gru = {\n" \
           "   noise_gru_bias,\n" \
           "   noise_gru_weights,\n" \
           "   noise_gru_recurrent_weights,\n" \
           "   %d, %.1f, ACTIVATION_RELU\n" \
           "};\n", \
           noise_gru.nb_inputs, \
           (float)(noise_gru.nb_neurons)
           );
    fprintf(fp, "\n");


    // dump weights of denoise_gru
    dump_array("denoise_gru_weights", denoise_gru.input_weights, denoise_gru.nb_inputs * denoise_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");
    dump_array("denoise_gru_recurrent_weights", denoise_gru.recurrent_weights, denoise_gru.nb_neurons * denoise_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");
    dump_array("denoise_gru_bias", denoise_gru.bias, denoise_gru.nb_neurons * 3, fp);
    fprintf(fp, "\n");

    // dump definition of denoise_gru
    fprintf(fp, "const GRULayer denoise_gru = {\n" \
           "   denoise_gru_bias,\n" \
           "   denoise_gru_weights,\n" \
           "   denoise_gru_recurrent_weights,\n" \
           "   %d, %.1f, ACTIVATION_TANH\n" \
           "};\n", \
           denoise_gru.nb_inputs, \
           (float)(denoise_gru.nb_neurons)
           );
    fprintf(fp, "\n");


    // dump weights of denoise_output
    dump_array("denoise_output_weights", denoise_output.input_weights, denoise_output.nb_inputs * denoise_output.nb_neurons, fp);
    fprintf(fp, "\n");
    dump_array("denoise_output_bias", denoise_output.bias, denoise_output.nb_neurons, fp);
    fprintf(fp, "\n");

    // dump definition of denoise_output
    fprintf(fp, "const DenseLayer denoise_output = {\n" \
           "   denoise_output_bias,\n" \
           "   denoise_output_weights,\n" \
           "   %d, %d, ACTIVATION_SIGMOID\n" \
           "};\n", \
           denoise_output.nb_inputs, \
           denoise_output.nb_neurons
           );
    fprintf(fp, "\n");


    // dump weights of vad_output
    dump_array("vad_output_weights", vad_output.input_weights, vad_output.nb_inputs * vad_output.nb_neurons, fp);
    fprintf(fp, "\n");
    dump_array("vad_output_bias", vad_output.bias, vad_output.nb_neurons, fp);
    fprintf(fp, "\n");

    // dump definition of vad_output
    fprintf(fp, "const DenseLayer vad_output = {\n" \
           "   vad_output_bias,\n" \
           "   vad_output_weights,\n" \
           "   %d, %d, ACTIVATION_SIGMOID\n" \
           "};\n", \
           vad_output.nb_inputs, \
           vad_output.nb_neurons
           );
    fprintf(fp, "\n");

    printf("\nDone. All the weights data has been dumped to %s\n", output_file);
    fclose(fp);
    return 0;
}

#define MAX_STR_LEN 128

void display_usage()
{
    printf("Usage: rnnoise_weight_dump\n" \
           "--output_file, -o: output c code file for rnnoise model weights. default: rnn_data.c\n" \
           "\n");
    return;
}


int main(int argc, char** argv)
{
    char output_file[MAX_STR_LEN] = "rnn_data.c";

    int c;
    while (1) {
        static struct option long_options[] = {
            {"output_file", required_argument, NULL, 'o'},
            {"help", no_argument, NULL, 'h'},
            {NULL, 0, NULL, 0}};

        /* getopt_long stores the option index here. */
        int option_index = 0;
        c = getopt_long(argc, argv, "ho:", long_options, &option_index);

        /* Detect the end of the options. */
        if (c == -1) break;

        switch (c) {
            case 'o':
                memset(output_file, 0, MAX_STR_LEN);
                strcpy(output_file, optarg);
                break;
            case 'h':
            case '?':
            default:
                /* getopt_long already printed an error message. */
                display_usage();
                exit(-1);
        }
    }

    rnnoise_weight_dump(output_file);

    return 0;
}
